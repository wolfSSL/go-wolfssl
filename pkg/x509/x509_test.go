package x509

import (
    "testing"
)

func TestParseCertificate(t *testing.T) {
    // Test certificate in DER format
    certDER := []byte{
        0x30, 0x82, 0x02, 0x58, 0x30, 0x82, 0x01, 0xc1, 0xa0, 0x03, 0x02, 0x01,
        0x02, 0x02, 0x09, 0x00, 0xb3, 0x8e, 0x4b, 0x4d, 0x91, 0x1c, 0xaa, 0x3f,
        0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,
        0x0b, 0x05, 0x00, 0x30, 0x1a, 0x31, 0x18, 0x30, 0x16, 0x06, 0x03, 0x55,
        0x04, 0x03, 0x0c, 0x0f, 0x54, 0x65, 0x73, 0x74, 0x20, 0x43, 0x65, 0x72,
        0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65,
    }

    cert, err := ParseCertificate(certDER)
    if err != nil {
        t.Fatalf("ParseCertificate() failed: %v", err)
    }

    if len(cert.Raw) != len(certDER) {
        t.Errorf("Raw certificate length mismatch: got %d, want %d", len(cert.Raw), len(certDER))
    }
}

func TestVerifyCertificate(t *testing.T) {
    // Create a root certificate pool
    roots := NewCertPool()

    // Test certificate verification
    cert := &Certificate{
        Raw: []byte{
            0x30, 0x82, 0x02, 0x58, 0x30, 0x82, 0x01, 0xc1, 0xa0, 0x03, 0x02, 0x01,
            0x02, 0x02, 0x09, 0x00, 0xb3, 0x8e, 0x4b, 0x4d, 0x91, 0x1c, 0xaa, 0x3f,
            0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,
            0x0b, 0x05, 0x00, 0x30, 0x1a, 0x31, 0x18, 0x30, 0x16, 0x06, 0x03, 0x55,
            0x04, 0x03, 0x0c, 0x0f, 0x54, 0x65, 0x73, 0x74, 0x20, 0x43, 0x65, 0x72,
            0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65,
        },
    }

    // Add a root certificate
    roots.AddCert(cert)

    // Verify the certificate
    err := cert.Verify(VerifyOptions{
        Roots: roots,
    })
    if err != nil {
        t.Fatalf("Verify() failed: %v", err)
    }
}
